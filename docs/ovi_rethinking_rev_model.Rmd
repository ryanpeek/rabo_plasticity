---
title: "Oviposition Logistic"
author: "Ryan Peek"
date: "Updated: `r format(Sys.Date())`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath("../"))
```

## What Permits Plasticity in Breeding Timing in River Frogs?

How might varying environmental conditions provide cues for breeding timing from year to year? For frogs that have an amazing plasticity in breeding oviposition timing (inital deposition of eggs) such as *Rana boylii*, there must be certain thresholds that exist (a cutoff which makes oviposition not possible, physiologically). However, beyond a given threshold, there also may be certain cues which act as important environmental markers in dynamic environments such as rivers. By utilizing both, it is likely that the odds of reproductive success improve, and over time this results in evolutionary success. For example, frogs that breed to soon are more likely to have eggs scoured out by late spring storms or have longer developmental/hatching times because water temperatures are lower. Frogs breeding later in the season may trade off greater egg deposition and hatching success with later metamorphosis and lower overwinter survival. 

We know that frogs from the same populations in the exact same locations can deposit eggs more than a month later or many weeks earlier than the average observed date of deposition, depending on the annual conditions (i.e., wetter or drier years). We suspect that the water temperature may be the most important driver in this plasticity, as it may act as a threshold which once exceeded, provides a very strong indicator of "summer" or future hydrologic condition.

However, the flow in a given reach of river can also be highly correlated with water temperature. Linkage between water temperature and patterns in flow may be tightly tied, particularly in rivers in the Sierra Nevada. Historically, Sierra Nevada river hydrology has been driven by a general Mediterranean pattern of wet (though variable) winter weather followed by spring snowmelt and warmer and drier summers. While temperature may exist as a spawning threshold, the actual initiation of breeding or spawning is highly variable in **R. boylii**, and likely requires additional enviromental cues such as changing water levels, flow magnitude, air temperature, humidity, etc.

These additional metrics may each act as environmental cues, but to conserve plasticity across environmental variablity present in a wide geographic range, it is unlikely that any of these can dictate oviposition independently (whereas a water temperature threshold may be a sole driver in some years). In order to determine the strongest predictor of breeding, we've collected oviposition data over 6 rivers in the Sierra Nevada from 2011 through 2016. In addition we collected a variety of metrics related to flow, air temperature, water temperature, water year index, day of water year, precipitation, and barometric pressure.

## Try Model, Model Fail

Let's try to assess whether water temperature, air temperature, flow (daily/weekly recession rates & discharge) play a role in predicting when breeding (oviposition occurs). To build this model we need to block by river, and by water year, as these are independent (though water year isn't *fixed*, it is fixed across all sites per each year).

First let's take a look at some test data. Using a subset (say just pull the **NF American**), can we build a model that gets at whether there is predictability in these variables despite shifts in timing and magnitude from year to year? Ideally this seems to be setup for a logistic regression, where 1 is the breeding initation or observation of eggs in the river, and 0 is all the days prior to that event. An *Event History Analysis* or *Survival Analysis* approach might work (see section on geometric distribution, Ch10, pg 328). 

### Get the Data & Tidy

```{r get and tidy data, eval=F, echo=F}

library(tidyverse)
library(lubridate)

load("data/master_dat_2011-2016.rda") 

# fill the REG col across all rows
#master_df$REG <- ifelse(master_df$site %in% c("MFA","MFY","RUB","SFY"), "R","U")

load("data/flow_dv_cfs_2011_6sites.rda") # updated and merged flows:

df <- master_df
# df <- master_df %>% filter(site!="MFY")
# df <- master_df %>% filter(month(date)>2 & month(date)<8 & !site=="MFA")
# df <- master_df %>% filter(month(date)>3 & month(date)<8 & site=="NFA" | site=="NFY")


# 2 NAs in dataset from 30 day avgs
df[!is.na(df$missData) & df$site=="RUB" & df$date==ymd("2011-05-26"),]$temp_30_max<-10.99
df[!is.na(df$missData) & df$site=="RUB" & df$date==ymd("2011-05-26"),]$temp_30_min<-9.7

rabo <- df[!is.na(df$missData),] %>% arrange(date)

# add unique rownames based on siteID
rabo <- rabo %>%
  mutate("siteID" = paste0(site, "-", row.names(.))) %>% 
  column_to_rownames(var = "siteID")  %>% as.data.frame
#names(rabo)
#rownames(rabo)

# create column with date for 15 and 30 day lags (for binomial logistic)
rabo_lag <- rabo %>% 
  mutate(d07 = date - 7, 
         d14 = date - 14,
         d21 = date - 21,
         d30 = date - 30) %>% 
  select(site, date, WY, d07:d30)

# rejoin / filter form orig dataset

rabo_bin7<- inner_join(df, rabo_lag, by=c("site"="site", "WY"="WY", "date"="d07")) %>% select(-c(date.y, d14:d30)) %>% mutate(lagEM="d07")
rabo_bin14 <- inner_join(df, rabo_lag, by=c("site"="site", "WY"="WY", "date"="d14")) %>% select(-c(date.y, d07:d30)) %>% mutate(lagEM="d14")
rabo_bin21 <- inner_join(df, rabo_lag, by=c("site"="site", "WY"="WY", "date"="d21")) %>% select(-c(date.y, d07:d30)) %>% mutate(lagEM="d21")
rabo_bin30 <- inner_join(df, rabo_lag, by=c("site"="site", "WY"="WY", "date"="d30")) %>% select(-c(date.y, d07:d21)) %>% mutate(lagEM="d30")

# bind up for one dataset of lags, add 1/0 col for breeding
rabo_LAGS<-rbind(rabo_bin7, rabo_bin14, rabo_bin21, rabo_bin30) %>% 
  mutate(breed = 0)
rm(list=ls(pattern = "rabo_bin*"))

# add breed col to orig dataset:
rabo <- rabo %>% mutate(breed = 1, lagEM="d00")

# make final logistic dataset, add 1/0 column
rabo_logist <- rbind(rabo_LAGS, rabo)

# fill the REG col across all rows
#rabo_logist$REG <- ifelse(rabo_logist$site %in% c("MFA","MFY","RUB","SFY"), "R","U")

#save(rabo_logist, file = "models/rabo_logistic_all_sites.rda")
```

Prepare data by removing much of the information that will be unused, and converting and scaling the data as needed.

```{r prepData, eval=T, echo=T}

library(tidyverse)
library(lubridate)
library(rethinking)

# custom scale function
cusScale <- function(x){
  (x - mean(x))/sd(x)
}

unScale <- function(x, y){
  (x * sd(y) + mean(y))
}

# LOAD DATA
load("models/rabo_logistic_all_sites.rda")

# UNREG: Filter down data, use only unreg sites
d1 <- dplyr::select(rabo_logist, site, breed, lagEM, DOWY, everything(), 
                    -date, -EM_per_km, -REG, -(obs_strt:apr_jul),
                    -len_km, -starts_with("CDEC"), -station, -DOY,
                    -WYsum, -lev_7_avg, -Q_cfs, -Q_min, -Q_7_cfs) %>% 
    #filter(!site=="MFA") %>% 
  filter(site=="NFY" | site=="NFA") %>%
  as.data.frame

# RM NAs, add id and site to rownames:
d1 <- d1 %>% filter(!is.na(temp_30_min))
#d1_rownames<- paste0(d1$site, "-",d1$WY, "-", seq(1:nrow(d1)))
d1$site <- as.factor(d1$site)
d1$lagEM <- as.factor(d1$lagEM)

# scale all data and rebind site and breed info:
d1s <- d1
d1s[,c(4:30)] <- apply(d1[,c(4:30)], 2, cusScale) # center and scale
d1s$site <- coerce_index(d1s$site) # for modeling
#d1s$WY <- coerce_index(d1s$WY) # for modeling
d1s$lagEM <- coerce_index(d1s$lagEM) # for modeling
#d1s <- d1s %>% rename(river=site, wyind=Index) # rename some vars

# update cols
d1$Qmx_log <- log(d1$Q_max)
d1$DOWY_log <- log(d1$DOWY)
d1s$DOWY <- d1$DOWY
d1$deltLevEX<-exp(d1$deltLev)
d1$lagEM<-coerce_index(d1$lagEM)
d1$obs <- 1:nrow(d1)
d1$river<-coerce_index(d1$site)

# only the breeding points?
#d1 <- d1 %>% filter(breed==1)
#d1s <- d1s %>% filter(breed==1)


# ALL DATA: Filter down data, use only reg sites
d2 <- dplyr::select(rabo_logist, site, breed, lagEM, DOWY, everything(), 
                    -date, -EM_per_km, -(obs_strt:apr_jul),
                    -len_km, -starts_with("CDEC"), -station, -DOY,
                    -WYsum, -lev_7_avg, -Q_cfs, -Q_min, -Q_7_cfs) %>% 
  filter(!site=="MFA", !site=="MFY") %>% #, !site=="NFY", !site=="NFA") %>%
  as.data.frame

# RM NAs, add id and site to rownames:
d2 <- d2 %>% filter(!is.na(temp_30_min)) #rm the NAs
d2$site <- factor(d2$site)
d2$REG_id <-ifelse(d2$REG=="R",1,0)
d2$lagEM <- as.factor(d2$lagEM)
d2 <- d2 %>% select(-REG)

# scale all data and rebind site and breed info:
d2s <- d2
d2s[,c(5:30)] <- apply(d2[,c(5:30)], 2, cusScale) # center and scale
d2s$site <- coerce_index(d2s$site) # for modeling
d2s$lagEM <- coerce_index(d2s$lagEM) # for modeling

# update cols
d2$Qmx_log <- log(d2$Q_max)
d2$DOWY_log <- log(d2$DOWY)
d2s$DOWY <- d2$DOWY
d2$deltLevEX<-exp(d2$deltLev)
d2$lagEM<-coerce_index(d2$lagEM)
d2$obs <- 1:nrow(d2)
d2$river<-coerce_index(d2$site)
d2s$WY_id <- coerce_index(d2$WY)

# only the breeding points?
#d2 <- d2 %>% filter(breed==1)
#d2s <- d2s %>% filter(breed==1)

dowy_labs<-c("Oct","Nov","Dec","Jan", "Feb","Mar", "Mar-15", "Apr-01", "Apr-15", "May-01", "May-15", "Jun-01", "Jun-15", "Jul-01", "Jul-15", "Aug", "Aug-15", "Sep")
dowy_breaks<-c(1, 32, 62, 93, 124, 152, 167, 183, 198, 213, 228, 244, 259, 274, 289, 305, 320, 336)
dowys<-data.frame("mon"=dowy_labs, "dowy"=dowy_breaks)

```

### Do Some Exploratory Modeling

After initially trying logistic regression, I think the better approach may be using a continuous variable (DOWY), and including breeding as a binary 1/0, or just use the breeding data. It would allow a better sense of how relevant the effect is for spawning date.

#### Poisson Models

```{r poisson1}
# dowy has to be positive
#d2s$WY_id <- coerce_index(d2$WY)
# breeding only
#d1 <- d1 %>% filter(breed==1)
#d1s <- d1s %>% filter(breed==1)

# Model 1: Varying Intercept for WY, breeding only, all sites
mP1<- map2stan(
  alist(
    DOWY ~ dpois(mu),
    log(mu) <- a + a_wy[WY_id] + bLEM*lagEM + bt7mx*temp_7_max + bt30mn*temp_30_min + bQCV*Q_CV + bdLev*deltLev + bwyi*Index + bdQ*deltQ + bReg*REG_id + btCV*temp_CV,
    a ~ dnorm(0, 10),
    a_wy[WY_id] ~ dnorm(0, sigma_wy),
    bLEM ~ dnorm(2, 10),
    c(bt7mx, bt30mn, bQCV, bdLev, bwyi, bdQ, bReg, btCV) ~ dnorm(0,10),
    sigma_wy ~ dcauchy(0,1)
),
data=d2s, iter=1e4, chains=3, cores=2)


# plots and stuff
plot(mP1)
dev.off()
#pairs(mP1)
precis(mP1, depth=2, warn=F)
plot(precis(mP1, pars = c("a_wy","bt7mx", "bt30mn", "blevCV", "bQCV", "bdLev", "bwyi", "bdQ",
                   "bReg","btCV", "sigma_wy"),  depth=2,warn=F))
```

So this means the model predicts a decrease in `DOWY` when `REG`==1, and an increase in `DOWY` with increasing `Water Index`. Interestingly, this model shows Rhats > 1, so something odd is going on here, and perhaps we should reduce the dnorm(mean back to 1 or 0). Here's the output from the **First Run** (`a ~ dnorm(0, 10)` and `a_site[site] ~ dnorm(a, sigma_site)`.


 > Changing the a ~ dnorm(0, 10) for the intercept made a big difference. Better Rhats and smaller SD across coefficients

 > Finally, changing the varying intercept to adapt not to the general intercept, but to 0 and the sigma_site appears to help.

``` 
          Mean StdDev lower 0.89 upper 0.89 n_eff Rhat
a         5.48   0.04       5.42       5.53  8453    1
a_wy[1]   0.02   0.06      -0.07       0.10  8056    1
a_wy[2]  -0.04   0.03      -0.09       0.00  8760    1
a_wy[3]  -0.03   0.03      -0.07       0.02  8895    1
a_wy[4]   0.02   0.04      -0.03       0.08  7641    1
a_wy[5]   0.01   0.04      -0.05       0.07  7785    1
a_wy[6]   0.02   0.03      -0.02       0.07  8715    1
bLEM     -0.03   0.01      -0.05      -0.02 13800    1
bt7mx     0.01   0.01      -0.01       0.03 14614    1
bt30mn   -0.01   0.01      -0.03       0.01 18636    1
bQCV      0.00   0.01      -0.01       0.02 18011    1
bdLev     0.00   0.01      -0.02       0.01 16095    1
bwyi      0.07   0.03       0.03       0.11  7893    1
bdQ       0.00   0.01      -0.02       0.01 16579    1
bReg     -0.04   0.01      -0.06      -0.01 20000    1
btCV      0.00   0.01      -0.02       0.01 20000    1
sigma_wy  0.05   0.04       0.01       0.10  4132    1
```


```{r poisson2}

# Model 2: scaled

mP2<- map2stan(
  alist(
    DOWY ~ dpois(mu),
    log(mu) <- a + a_site[site] + bLEM*lagEM + bt7mx*temp_7_max + bt30mn*temp_30_min + blevCV*lev_CV + bQCV*Q_CV + bdLev*deltLev + bwyi*Index + bReg*REG_id + btCV*temp_CV,
    a ~ dnorm(0,10),
    a_site[site] ~ dnorm(0, sigma_site),
    bLEM ~ dnorm(2, 10),
    c(bt7mx, bt30mn, blevCV, bQCV, bdLev, bwyi, bReg, btCV) ~ dnorm(0,10),
    sigma_site ~ dcauchy(0,1)
),
data=d2s, iter=1e4, chains=3, cores=2)

# plots and stuff
plot(mP2)
dev.off()
precis(mP2, depth=2, warn=F)
plot(precis(mP2, depth=2,warn=F))

# using BROOM & TIDY!
library(broom)
tidy(mP2@stanfit)
td_mean <- tidy(mP2@stanfit,conf.int = TRUE, rhat = T, ess = T)
td_median<-tidy(mP2@stanfit,conf.int = TRUE, rhat = T, ess = T,
     estimate.method = "median")
tds <- rbind(mutate(td_mean, method = "mean"),
               mutate(td_median, method = "median")) %>% mutate(estimate=round(estimate, 3))
head(tds)
# plot
ggplot(tds[tds$term!="dev" & tds$term!="a",], aes(estimate, term)) +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
    geom_point(aes(color = method))

# compare models
compare(mP1, mP2)
```

```{r poisson3}

# Model 3: scaled

mP3<- map2stan(
  alist(
    DOWY ~ dpois(mu),
    log(mu) <- a + a_wy[WY_id] + bt7mx*temp_7_max + bt30mn*temp_30_min + blevCV*lev_CV + 
      bQCV*Q_CV + bdLev*deltLev + bwyi*Index + bdQ*deltQ + bReg*REG_id + btCV*temp_CV,
    a ~ dnorm(0, 10),
    a_wy[WY_id] ~ dnorm(0, sigma_wy),
    c(bt7mx, bt30mn, blevCV, bQCV, bdLev, bwyi, bdQ, bReg, btCV) ~ dnorm(0,10),
    sigma_wy ~ dexp(1)
),
data=d2s, iter=1e4, chains=4, cores=2)



# plots and stuff
plot(mP3)
dev.off()
precis(mP3, depth=2, warn=F)
plot(precis(mP3, pars = c("a_wy","bt7mx", "bt30mn", "blevCV", "bQCV", "bdLev", "bwyi", "bdQ",
                   "bReg","btCV", "sigma_wy"), depth=2, warn=F))
abline(v=0, lty=2)

compare(mP1, mP3)

```

Looks like the model with `temp_7_max`, and `temp_30_mn` performed best, but not significantly so. The model with `ppt` and other temp values may be important. Ultimately we need to make some plots to figure this out. Also helps to create an ensemble model so that any one parameter gets "averaged" and avoids issues with trying lots of different models until you get one that "works".

I can't figure out how to extract predictions from my ensemble model for a given set of variables, or how to make a residual plot. 

#### Gaussian Regression

```{r gaussian-mG4}

mG4 <- map2stan(
  alist(
    DOWY ~ dnorm( mu , sigma),
    mu <- a + a_site[site] + bt7mx*temp_7_max + 
      bt30mn*temp_30_min + bQCV*Q_CV + 
      bdLev*deltLev +  blevCV*lev_CV + bwyi*Index + 
      bLEM*lagEM + bdQ*deltQ + bReg*REG_id + btCV*temp_CV,
    a ~ dnorm(0 , 10) ,
    a_site[site] ~ dnorm(0, sigma_site),
    bLEM ~ dnorm(2, 10),
    bt7mx ~ dnorm( 11 , 10 ) ,
    bt30mn ~ dnorm( 7 , 10 ) ,
    bQCV ~ dnorm(5, 10),
    bdLev ~ dnorm(1, 10),
    blevCV ~ dnorm(2,10),
    bwyi ~ dnorm(6, 10),
    c(bdQ, bReg) ~ dnorm(0, 10),
    btCV ~ dnorm(8, 10),
    sigma ~ dnorm(1, 10),
    sigma_site ~ dcauchy(0,1)
  ),
  data=d2, iter=1e4 , chains=3, cores=2
)

plot(mG4)
dev.off()
precis(mG4, depth=2, warn=F)
plot(precis(mG4, depth=1))

```

Very similar to model 5 but wider and messier.

```
             Mean StdDev lower 0.89 upper 0.89 n_eff Rhat
a          169.69  11.18     151.89     187.45  4043    1
a_site[1]   -0.82   2.24      -4.53       1.90  5408    1
a_site[2]    1.50   2.47      -1.50       5.16  3495    1
a_site[3]   -1.44   2.51      -5.12       1.78  3812    1
a_site[4]    0.89   2.23      -1.94       4.46  6520    1
bLEM        -6.54   0.78      -7.77      -5.28  5937    1
bt7mx        0.76   0.66      -0.30       1.81  5625    1
bt30mn       1.04   0.75      -0.11       2.29 10328    1
bQCV         0.06   0.20      -0.26       0.36 10106    1
bdLev        2.65   8.65     -11.23      16.31 12971    1
blevCV       1.32   0.47       0.54       2.05 10589    1
bwyi         7.73   0.47       6.99       8.50  7941    1
bdQ        -10.45   6.46     -20.38       0.28 11669    1
bReg        -7.44   3.08     -12.07      -2.97  5210    1
btCV        -0.04   0.23      -0.41       0.32 12987    1
sigma        7.77   0.60       6.83       8.69 12340    1
sigma_site   2.27   2.20       0.05       4.55  2370    1
```


```{r gaussian-mG5}

mG5 <- map2stan(
  alist(
    DOWY ~ dnorm( mu , sigma),
    mu <- a + a_site[site] + bt7mx*temp_7_max +
      bt30mn*temp_30_min + blevCV*lev_CV + 
      bQCV*Q_CV + bdLev*deltLev + bwyi*Index + 
      bLEM*lagEM + bdQ*deltQ + bReg*REG_id + btCV*temp_CV,
    a ~ dnorm(0, 10),
    a_site[site] ~ dnorm(0, sigma_site),
    c(bt7mx, bt30mn, blevCV, bQCV, bdLev, bwyi, bdQ, bReg, btCV, bLEM) ~ dnorm(0,10),
    sigma ~ dnorm(0,10),
    sigma_site ~ dcauchy(0,1)
  ),
  data=d2s, iter=1e4 , chains=3, cores=2
)

plot(mG5)
dev.off()
precis(mG5, depth=2, warn=F)
plot(precis(mG5, depth=2))

compare(mP1, mP2, mG4, mG5)

```

So best model is Gaussian Model 5!

```
             Mean StdDev lower 0.89 upper 0.89 n_eff Rhat
a            1.98  10.00     -14.40      17.61  4780    1
a_site[1]  230.71  10.46     212.93     246.35  4589    1
a_site[2]  235.52  10.29     218.93     251.86  4590    1
a_site[3]  221.39  14.51     197.89     243.83  4669    1
a_site[4]  226.73  14.42     203.59     249.41  4695    1
bt7mx        2.11   1.36      -0.04       4.29  8834    1
bt30mn       1.69   1.04       0.07       3.37 15000    1
blevCV       2.68   1.00       1.12       4.32 13570    1
bQCV         0.91   1.03      -0.75       2.53 12174    1
bdLev        1.10   1.03      -0.50       2.78 10430    1
bwyi        15.93   0.95      14.42      17.44 12178    1
bdQ         -2.36   1.06      -4.10      -0.71  9948    1
bReg         1.02   9.97     -14.99      16.73  8858    1
btCV        -0.38   0.87      -1.81       0.96 15000    1
bLEM        -6.17   0.78      -7.41      -4.94  9892    1
sigma        7.67   0.59       6.74       8.58 15000    1
sigma_site 242.15 101.03     115.51     359.43  9058    1

```
### Simplify Models

Too much going on in the models above, so let's simplify and look at a few variables at a time across all sites, and see how predictions/models improve/decrease. Sticking with breeding only dates at this point, but all sites.

```{r simplifiedMods}

d2b <- d2 %>% filter(breed==1)
d2sb <- d2s %>% filter(breed==1)
d2sb$DOWY_s <- cusScale(d2sb$DOWY)

# Temp Only, DOWY scaled
mS1t <- map2stan(
  alist(
    DOWY_s ~ dnorm( mu , sigma),
    mu <- a + a_wy[WY_id] + bt7mx*temp_7_max + bReg*REG_id,
    a ~ dnorm(0, 10),
    a_wy[WY_id] ~ dnorm(0, sigma_wy),
    c(bt7mx, bReg) ~ dnorm(0,10),
    sigma ~ dnorm(0,10),
    sigma_wy ~ dcauchy(0,1)
  ),
  data=d2sb, iter=1e4 , chains=3, cores=2
)

# delt_Lev Only, DOWY scaled
mS1dL <- map2stan(
  alist(
    DOWY_s ~ dnorm( mu , sigma),
    mu <- a + a_wy[WY_id] + bdL*deltLev + bReg*REG_id,
    a ~ dnorm(0, 10),
    a_wy[WY_id] ~ dnorm(0, sigma_wy),
    c(bdL, bReg) ~ dnorm(0,10),
    sigma ~ dnorm(0,10),
    sigma_wy ~ dcauchy(0,1)
  ),
  data=d2sb, iter=1e4 , chains=3, cores=2
)

# Q_CV Only, DOWY scaled
mS1Qcv <- map2stan(
  alist(
    DOWY_s ~ dnorm( mu , sigma),
    mu <- a + a_wy[WY_id] + bQCV*Q_CV + bReg*REG_id,
    a ~ dnorm(0, 10),
    a_wy[WY_id] ~ dnorm(0, sigma_wy),
    c(bQCV, bReg) ~ dnorm(0,10),
    sigma ~ dnorm(0,10),
    sigma_wy ~ dcauchy(0,1)
  ),
  data=d2sb, iter=1e4 , chains=3, cores=2
)

# delt Q Only, DOWY scaled
mS1dQ <- map2stan(
  alist(
    DOWY_s ~ dnorm( mu , sigma),
    mu <- a + a_wy[WY_id] + bdQ*deltQ + bReg*REG_id,
    a ~ dnorm(0, 10),
    a_wy[WY_id] ~ dnorm(0, sigma_wy),
    c(bdQ, bReg) ~ dnorm(0,10),
    sigma ~ dnorm(0,10),
    sigma_wy ~ dcauchy(0,1)
  ),
  data=d2sb, iter=1e4 , chains=3, cores=2
)


# temp_CV, DOWY scaled
mS1tCV <- map2stan(
  alist(
    DOWY_s ~ dnorm( mu , sigma),
    mu <- a + a_wy[WY_id] + btCV*temp_CV + bReg*REG_id,
    a ~ dnorm(0, 10),
    a_wy[WY_id] ~ dnorm(0, sigma_wy),
    c(btCV, bReg) ~ dnorm(0,10),
    sigma ~ dnorm(0,10),
    sigma_wy ~ dcauchy(0,1)
  ),
  data=d2sb, iter=1e4 , chains=3, cores=2
)
```

```{r compare-save_mods}


compare(mS1dL, mS1dQ, mS1Qcv, mS1t, mS1tCV)

save(mS1dL, mS1dQ, mS1Qcv, mS1t, mS1tCV, 
     file = "models/gaussian_simple_varWY.rda")

```

It looks like the best model is `tCV`, `Qcv`, `t7mx`, `dL`, then `dQ`. But not much differentiating these.

```
       WAIC pWAIC dWAIC weight    SE  dSE
mS1tCV 31.3   8.3   0.0   0.35 10.77   NA
mS1Qcv 32.4   8.1   1.1   0.21 10.18 5.63
mS1t   32.6   8.0   1.3   0.18 10.20 2.14
mS1dL  32.8   8.1   1.5   0.17 10.94 5.24
mS1dQ  34.0   8.0   2.7   0.09 10.88 3.23
```

```{r broom_tables_simple}

# using BROOM & TIDY!
library(broom)

td_mean <- tidy(mS1tCV@stanfit,conf.int = TRUE, rhat = T, ess = T)
td_median<-tidy(mS1tCV@stanfit,conf.int = TRUE, rhat = T, ess = T,
     estimate.method = "median")

tds <- rbind(mutate(td_mean, method = "mean"),
               mutate(td_median, method = "median")) %>% mutate(estimate=round(estimate, 3))
head(tds)

# plot
ggplot(tds[tds$term!="dev" & tds$term!="a",], aes(estimate, term)) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
  geom_point(aes(fill = method), pch=21, alpha=0.6, size=4)+
  geom_vline(xintercept=0, lty=2, col="maroon")
  
```

### PLOTS: Simple Counterfactual

```{r ctrfactual_t7mx}

post1_t7<-extract.samples(mS1t)

d2sb$site <- d2b$site # change back to site name

# test plot
plot( DOWY ~ temp_7_max , data=d2sb, pch=ifelse(d2sb$WY_id==1, 16, 21), col=ifelse(d2sb$REG_id==0, rangi2, "red"))

# the sequence to link model to
temp_7_max.seq <- seq( from=-1.5 , to=3 , length.out = 30)

# use link to compute mu for each sample from posterior
# and for each temp in temp.seq
mu1_U <- link( mS1t, 
            data=data.frame(temp_7_max=temp_7_max.seq,
                            REG_id=0, WY_id=3))
mu1_R <- link( mS1t, 
            data=data.frame(temp_7_max=temp_7_max.seq,
                            REG_id=1, WY_id=3))

# summarize MU
mu1U.mean <- apply( mu1_U , 2 , mean )
mu1R.mean <- apply( mu1_R , 2 , mean )

# mean DOWY for unreg:
mean(unScale(mu1U.mean, d2sb$DOWY)) # 229
# mean DOWY for Reg:
mean(unScale(mu1R.mean, d2sb$DOWY)) # 219 (grand mean)

# So a 10 day mean difference between regulated and unregulated river

# summarize the distribution of mu
mu1U.HPDI89 <- apply( mu1_U , 2 , HPDI , prob=0.89 )
mu1R.HPDI89 <- apply( mu1_R , 2 , HPDI , prob=0.89 )
mu1U.HPDI97 <- apply( mu1_U , 2 , HPDI , prob=0.97 )
mu1R.HPDI97 <- apply( mu1_R , 2 , HPDI , prob=0.97 )
mu1U.HPDI67 <- apply( mu1_U , 2 , HPDI , prob=0.67 )
mu1R.HPDI67 <- apply( mu1_R , 2 , HPDI , prob=0.67 )

# use type="n" to hide raw data
plot( DOWY_s ~ temp_7_max , data=d2sb, pch=ifelse(d2sb$WY_id==1, 16, 21), col=ifelse(d2sb$REG_id==0, rangi2, "red"), ylim=c(-2,2.5), xlim=c(-1.5,3))

# add axes
# aty <- seq(183, 289, by = 15)
# labelsY<-dowys$mon[8:15]
# axis(side=2, at = aty, labels=labelsY, las=1)

# loop over samples and plot each mu4 value
# for ( i in 1:50 )
#     lines( temp_7_max.seq , mu1_U[i,],
#            col=col.alpha(rangi2,0.2) )

lines( temp_7_max.seq , mu1U.mean, lwd=2, col="darkblue" ) #unreg
text(1.9, 0.3, labels = "Unreg (u=224)", col="darkblue")
lines( temp_7_max.seq , mu1R.mean, lwd=2, col="maroon", lty=2 ) #reg
text(-0.7, -1.3, labels = "Reg (u=214)", col="maroon")

# 97% prob intervals
shade( mu1U.HPDI97 , temp_7_max.seq,
      col = col.alpha("darkblue",alpha=0.2))
shade( mu1R.HPDI97 , temp_7_max.seq,
      col = col.alpha("maroon",alpha=0.2))

# identify some points
identify( x=d2sb$temp_7_max , y=d2sb$DOWY_s , 
          labels=paste0(d2sb$site,"-",d2sb$WY_id), cex=0.8 )


```


```{r counterfactual_QCV}

# extract posterior estimates
post1_QCV<-extract.samples(mS1Qcv)

# the sequence to link model to
Q_CV.seq <- seq(from=-1.5 , to=4 , length.out = 36)

# use link to compute mu for each sample from posterior
# and for each temp in temp.seq
mu1_U <- link( mS1Qcv, 
            data=data.frame(Q_CV=Q_CV.seq,
                            REG_id=0, WY_id=3))
mu1_R <- link( mS1Qcv, 
            data=data.frame(Q_CV=Q_CV.seq,
                            REG_id=1, WY_id=3))

# summarize MU
mu1U.mean <- apply( mu1_U , 2 , mean )
mu1R.mean <- apply( mu1_R , 2 , mean )

# mean DOWY for unreg:
mean(unScale(mu1U.mean, d2sb$DOWY)) # 228
# mean DOWY for Reg:
mean(unScale(mu1R.mean, d2sb$DOWY)) # 218 (grand mean)

# So a 10 day mean difference between regulated and unregulated river

# summarize the distribution of mu
mu1U.HPDI89 <- apply( mu1_U , 2 , HPDI , prob=0.89 )
mu1R.HPDI89 <- apply( mu1_R , 2 , HPDI , prob=0.89 )
mu1U.HPDI97 <- apply( mu1_U , 2 , HPDI , prob=0.97 )
mu1R.HPDI97 <- apply( mu1_R , 2 , HPDI , prob=0.97 )
mu1U.HPDI67 <- apply( mu1_U , 2 , HPDI , prob=0.67 )
mu1R.HPDI67 <- apply( mu1_R , 2 , HPDI , prob=0.67 )

# use type="n" to hide raw data
plot( DOWY_s ~ Q_CV , data=d2sb, pch=ifelse(d2sb$WY_id==1, 16, 21), col=ifelse(d2sb$REG_id==0, rangi2, "red"), ylim=c(-1.5, 2.5), xlim=c(-1.5,4.25))

lines( Q_CV.seq , mu1U.mean, lwd=2, col="darkblue" ) #unreg
text(3, 0.6, labels = "Unreg (u=237)", col="darkblue")
lines( Q_CV.seq , mu1R.mean, lwd=2, col="maroon", lty=2 ) #reg
text(2.7, -0.7, labels = "Reg (u=227)", col="maroon")

# 97% prob intervals
shade( mu1U.HPDI97 , Q_CV.seq,
      col = col.alpha("darkblue",alpha=0.2))
shade( mu1R.HPDI97 , Q_CV.seq,
      col = col.alpha("maroon",alpha=0.2))

# identify some points
identify( x=d2sb$Q_CV , y=d2sb$DOWY_s , 
          labels=paste0(d2sb$site,"-",d2sb$WY_id), cex=0.8 )

```

#### PLOTS: Obs vs. Predicted

```{r simdata_obs_pred}

mu1s <- link( mS1s )

# summarize samples across cases
mu.mean <- apply( mu1s , 2 , mean )
mu.PI <- apply( mu1s , 2 , PI )

# simulate observations, uses original data
temp.sim <- sim( mS1s , n=1e4 )
temp.PI <- apply( temp.sim , 2 , PI )

# now plot
plot( mu.mean ~ d2sb$DOWY_s , pch=16,
      col=ifelse(d2sb$REG_id==0, rangi2, "red"), 
      ylim=range(mu.PI) ,
      xlab="Observed Date of Spawning" , 
      ylab="Predicted Date of Spawning")
abline( a=0 , b=1 , lty=2 )

for ( i in 1:nrow(d2sb) )
    lines( rep(d2sb$DOWY_s[i],2) , c(mu.PI[1,i],mu.PI[2,i]) ,
        col=ifelse(d2sb$REG_id[i]==0, rangi2, "red") )

identify( x=d2sb$DOWY_s , y=mu.mean , 
          labels=paste0(d2sb$site,"-",d2sb$WY_id), cex=0.8 )

```

Predicted spawning dates agains observed, with 89% confidence intervals of the average prediction, dashed line is perfect prediction.


#### PLOTS: Prediction Error

```{r plot Prediction Error}
# compute residuals
dowy.resid <- d2sb$DOWY_s - mu.mean

# get ordering by DOWY rate
o <- order(dowy.resid)

# make the plot
dotchart( dowy.resid[o] ,
          labels=paste(d2sb$site[o],"-",d2sb$WY_id[o]) ,
          xlim=c(-2,2) , cex=0.6 )
abline( v=0 , col=col.alpha("black",0.2) )

for ( i in 1:nrow(d2sb) ) {
    j <- o[i] # which site in order
    lines( d2sb$DOWY_s[j]-c(temp.PI[1,j],temp.PI[2,j]) , rep(i,2) )
    points( d2sb$DOWY_s[j]-c(temp.PI[1,j],temp.PI[2,j]) ,
            rep(i,2),
            pch=3 , cex=0.6 , col=rangi2 )
}

```

Average prediction error for each site, with 89% interval of the mean (black line) and 89% prediction interval (blue +)

```{r residual plot}

# compute expected value at MAP,for each obs
mu <- coef(mS1s)['a']+coef(mS1s)['a_wy[4]'] + coef(mS1s)['bt7mx']*d2sb$temp_7_max

mu <- coef(mS1s)['a'] + coef(mS1s)['bdL']*d2sb$deltLev

# compute residual for each point
m.resid <- d2sb$temp_7_max - mu
m.resid <- d2sb$deltLev - mu

# if resid positive it means obs rate is in excess of what we would expect
plot( DOWY_s ~ deltLev , d2sb , 
      col=ifelse(d2sb$REG_id==0, rangi2, "red"), pch=16,
      xlim=c(-2,3.5), ylim=c(-2,3))
abline( a=coef(mS1s)["a"], b=coef(mS1s)['bdL'])

# temp
plot( DOWY_s ~ temp_7_max , d2sb , 
      col=ifelse(d2sb$REG_id==0, rangi2, "red"), pch=16,
      xlim=c(-2,3.5), ylim=c(-2,3))
abline( a=(coef(mS1s)["a_wy[4]"]+coef(mS1s)["a"]),
        b=coef(mS1s)['bt7mx'])

# loop over points
for ( i in 1:length(m.resid) ) {
    #x <- d2sb$temp_7_max[i] # x location of line segment
    x <- d2sb$deltLev[i]
    y <- d2sb$DOWY_s[i] # observed endpoint of line segment
    # draw the line segment
    lines( c(x,x) , c(mu[i],y) , lwd=0.5 , col=col.alpha("black",0.7) )
}

identify( x=d2sb$temp_7_max , y=d2sb$DOWY_s , 
          labels=paste0(d2sb$site,"-",d2sb$WY_id), cex=0.8 )

identify( x=d2sb$deltLev , y=d2sb$DOWY_s , 
          labels=paste0(d2sb$site,"-",d2sb$WY_id), cex=0.8 )


```

Points above the line have higher (later) than expected breeding times, vs. below they have earlier than expected breeding times

### Interaction Models
```{r interaction models}

# Interaction w WY
mS2 <- map2stan(
  alist(
    DOWY ~ dnorm( mu , sigma),
    mu <- a + a_wy[WY_id] + bt7mx*temp_7_max + bReg*REG_id +
      bt7mxWY*(temp_7_max * Index),
    a ~ dnorm(0, 10),
    a_wy[WY_id] ~ dnorm(0, sigma_wy),
    c(bt7mx, bt7mxWY, bReg) ~ dnorm(0,10),
    sigma ~ dnorm(0,10),
    sigma_wy ~ dcauchy(0,1)
  ),
  data=d2sb, iter=1e4 , chains=3, cores=2
)

# Interation w WY, intercept by SITE
mS3 <- map2stan(
  alist(
    DOWY ~ dnorm( mu , sigma),
    mu <- a + a_site[site] + bt7mx*temp_7_max + bReg*REG_id +
      bt7mxWY*(temp_7_max * Index),
    a ~ dnorm(0, 10),
    a_site[site] ~ dnorm(0, sigma_site),
    c(bB, bt7mx, bt7mxWY, bReg) ~ dnorm(0,10),
    sigma ~ dnorm(0,10),
    sigma_site ~ dcauchy(0,1)
  ),
  data=d2sb, iter=1e4 , chains=3, cores=2
)


plot(mS2)
dev.off()
precis(mS2, depth=2, warn=F)
precis(mS3, depth=2, warn=F)
plot(precis(mS2, depth=2))
plot(precis(mS3, depth=2))

compare(mS2, mS3)

# using BROOM & TIDY!
library(broom)
tidy(mP2@stanfit)
td_mean <- tidy(mP2@stanfit,conf.int = TRUE, rhat = T, ess = T)
td_median<-tidy(mP2@stanfit,conf.int = TRUE, rhat = T, ess = T,
     estimate.method = "median")
tds <- rbind(mutate(td_mean, method = "mean"),
               mutate(td_median, method = "median")) %>% mutate(estimate=round(estimate, 3))
head(tds)
# plot
ggplot(tds[tds$term!="dev" & tds$term!="a",], aes(estimate, term)) +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
    geom_point(aes(color = method))
```


#### OLD Plots

```{r plots_mG5_t7max}
post4<-extract.samples(mG4)
post5<-extract.samples(mG5)

plot( DOWY ~ temp_7_max , data=d2, pch=ifelse(d2$lagEM==1, 16, 21), col=ifelse(d2$REG_id==0, rangi2, "red"))

temp_7_max.seq <- seq( from=6 , to=18 , by=0.5)

# use link to compute mu for each sample from posterior
# and for each temp in temp.seq
mu4 <- link( mG4, 
            data=data.frame(temp_7_max=temp_7_max.seq,lagEM=1, 
                            temp_30_min=8, lev_CV=0, site=1,
                            Q_CV=0, deltLev=0, Index=6,
                            deltQ=0, REG_id=0, temp_CV=0))
mu5 <- link( mG5, 
            data=data.frame(temp_7_max=temp_7_max.seq,lagEM=1, 
                            temp_30_min=8, lev_CV=0, site=1,
                            Q_CV=0, deltLev=0, Index=6,
                            deltQ=0, REG_id=0, temp_CV=0))

# use type="n" to hide raw data
plot( DOWY ~ temp_7_max , data=d2, pch=ifelse(d2$lagEM==1, 16, 21), col=ifelse(d2$WY==2011, rangi2, "red"), yaxt='n', ylab="", xlim=c(6,18))

# add axes
aty <- seq(183, 289, by = 15)
labelsY<-dowys$mon[8:15]
#axis(side=2, at = aty, las=1)
axis(side=2, at = aty, labels=labelsY, las=1)

# loop over samples and plot each mu4 value
# for ( i in 1:50 )
#     lines( temp_7_max.seq , mu4[i,] , pch=21 , col="gray", bg=col.alpha(rangi2,0.2) )


# summarize the distribution of mu4
mu4.mean <- apply( mu4 , 2 , mean )
mu4.HPDI89 <- apply( mu4 , 2 , HPDI , prob=0.89 )
mu4.HPDI97 <- apply( mu4 , 2 , HPDI , prob=0.97 )
mu4.HPDI67 <- apply( mu4 , 2 , HPDI , prob=0.67 )

lines( temp_7_max.seq , mu4.mean )
shade( mu4.HPDI97 , temp_7_max.seq)
shade( mu4.HPDI89 , temp_7_max.seq)
shade( mu4.HPDI67 , temp_7_max.seq)


# identify some points
identify( x=d2$temp_7_max , y=d2$DOWY , 
          labels=paste0(d1$site,"-",d2$WY), cex=0.8 )
```



```{r plots_mG4_levDelt}
deltLev.seq <- seq( from=-5 , to=2.3 , length.out = 40)
#unScale(deltLev.seq, d2$deltLev)

# use link to compute mu for each sample from posterior
# and for each temp in temp.seq
mu4 <- link( mG4, 
            data=data.frame(temp_7_max=10, lagEM=1, 
                            temp_30_min=8, lev_CV=0, site=4,
                            Q_CV=0, Index=6,
                            deltQ=0, REG_id=0, temp_CV=0,
                            deltLev=deltLev.seq))

# use type="n" to hide raw data
plot( DOWY ~ deltLev , data=d2, pch=ifelse(d2$lagEM==1, 16, NA), col=ifelse(d2$WY==2011, rangi2, "red"))

# loop over samples and plot each mu value
for ( i in 1:40 )
    lines( deltLev.seq , mu4[i,],
           col=col.alpha(rangi2,0.2) )# 10C

# summarize the distribution of mu
mu4.mean <- apply( mu4 , 2 , mean )
mu4.HPDI89 <- apply( mu4 , 2 , HPDI , prob=0.89 )
mu4.HPDI97 <- apply( mu4 , 2 , HPDI , prob=0.97 )
mu4.HPDI67 <- apply( mu4 , 2 , HPDI , prob=0.67 )

plot( DOWY ~ deltLev , data=d2, pch=ifelse(d2$lagEM==1, 16, NA), col=ifelse(d2$WY==2011, rangi2, "red"))

lines( deltLev.seq , mu4.mean )
shade( mu4.HPDI97 , deltLev.seq, col = col.alpha("purple3", 0.2) )
shade( mu4.HPDI89 , deltLev.seq)
shade( mu4.HPDI67 , deltLev.seq, col=col.alpha("gray10", 0.2))

# identify some points
identify( x=d2$deltLev , y=d2$DOWY , 
          labels=paste0(d2$site,"-",d2$WY), cex=0.8 )

```

Maybe try an obs vs. modeled plot but use the regulated data...see how far off it is from the observed.


#### Notes from Myfanwy 2017-05-24

Use DOWY, not binomial, sites are coin flips. What triggers breeding, but doesn't help answer more important factors of what drives breeding? Want response to be as continuous as possible. 

**DOWY as response**
gammaPoisson, has individual "rate", rate should be affected in same way by different predictor variables. Different sites as nested variables, rate varies by site. 

**Survival Analysis**

How long does an event take to occur, (i.e., time to breeding)? Freezing over in a lake as example. Continuous segmented regression, (tobit regression) + probit model with time series with latent variable.

**MultiState Model**

predicting frequencies that will be occupied on radio, occupied vs. not.

Hidden Markov model, model conditions leading up to observable state (hidden state). Hidden markov poisson, describe variability that characterizes this latent state that you don't observe, but you know it drives the latent state.

Eric Van Cleaves (multistate modeler, spatial component)

Input matrix: 365 x 30 variables
Each row is day of year
Whether a breeding event occurred on that day as binomial




```{r gamPoisson}

d1f <- d1 %>% filter(breed==1) # NFY and NFA breeding only

#change delts to positive:
d1f$deltQexp <- exp(d1f$deltQ)
d1f$deltLevexp <- exp(d1f$deltLev)
d1f$log_DOWY <- log(d1f$DOWY)

mgP1 <- map2stan(
  alist(
    log_DOWY ~ dgampois(mu, scale),
    log(mu) <- a + bt7mx*temp_7_max + bwyi*Index + bdeltLev * deltLevexp +
      bWairmx*W_air_30_max + blevCV*lev_CV,
    a ~ dnorm(0, 10),
    c(bt7mx, bwyi, bdeltLev, bWairmx, blevCV) ~ dnorm(0,1),
    scale ~ dcauchy(0,1)
  ),
  data=d1f,
  constraints=list(scale="lower=0"),
  start=list(scale=1),
  warmup=1000, iter=8000, chains=2, cores=2)

precis(mgP1)
plot(mgP1)

postcheck(mgP1)
#blue points show the empirical proportion on each row of the data
#open circles are the posterior mean p, with 89% percentile interval
# + symbols mark the 89% interval of predicted counts for breeding. Lots of dispersion expected here.


postgP1 <- extract.samples(mgP1)
quantile( logistic(postgP1$a) , c(0.025,0.5,0.975) )

# draw posterior mean dgam distribution
curve( dgampois(x,mean(logistic(postmgP1$a)),mean(postmgP1$scale)) , from=0 , to=1 ,
    ylab="Density" , xlab="probability", ylim=c(0,3) , lwd=2 )
# draw 100 beta distributions sampled from posterior
for ( i in 1:100 ) {
    p <- logistic( postmgP1$a[i] )
    scale <- postmgP1$scale[i]
    curve( dgampois(x,p,scale) , add=TRUE , col=col.alpha("black",0.2) )
}


```





```{r}
# show density of log-odds
coef(mG4)

# make some plots
plot(DOWY ~ Q_CV, data=d2, pch=ifelse(d2$lagEM==1, 16, 21), col=ifelse(d2$WY==2011, rangi2, "red"))

abline(a=coef(mG4)["a"], b=coef(mG4)["bQCV"]*d2$Q_CV,
       col="black", lty=2)
abline(a=coef(mG4)["a"], b=coef(mG4)["bQCV"]*d2$Q_CV,
       col="black", lty=2)


# vars:
#a_lag[lagEM] + bt7mx*temp_7_max + bt30mn*temp_30_min + bQCV*Q_CV + bdLev*deltLevEX

# counterfactual
d.pred <- list(
    lagEM = rep(1,30),
    #DOWY = seq(150,300, length.out = 50),
    temp_7_max = seq(6,16, length.out = 30)
    #temp_30_min = seq(4,16, length.out = 30),
    #Q_CV = seq(0,40, length.out = 30),
    #deltLevEX = seq(0.7, 1.2, length.out = 30)
)

#a_lag_sims <- rnorm(20000,,post1$sigma_lag)
#a_lag_sims <- matrix(a_lag_sims,2000,10)
link.mP1 <- link( mP2 , n=2000 , data=d.pred)

# plot raw data
plot(d1$DOWY~d1$temp_7_max, pch=ifelse(d1$lagEM==1, 16, 21),
     col=ifelse(d1$WY==1, rangi2, "red"),
     #xlim=c(0,300), ylim=c(0,30),
     xlab="Temp 7 max" , ylab="DOWY")

# plot posterior median
mu.median <- apply( link.mP1 , 2 , median )
lines(d.pred$temp_7_max, mu.median)

# plot 97%, 89%, and 67% intervals (all prime numbers)
mu.PI <- apply( link.mP1 , 2 , PI , prob=0.97 )
shade(mu.PI, d.pred$temp_7_max )
mu.PI <- apply( link.mP1 , 2 , PI , prob=0.89 )
shade(mu.PI, d.pred$temp_7_max )
mu.PI <- apply( link.mP1 , 2 , PI , prob=0.67 )
shade(mu.PI, d.pred$temp_7_max )

```

```{r jacobgampoisson}

#########
# from Jacob 05/17/17
mz43 <- map2stan(
  alist(
    Zoops ~ dgampois(mu,scale),
    log(mu) <- a_site[site_id] + bt*temp + bno * NO3.N + bp * PO4.P + bd * DOC + bj * JulianDay,
    a_site[site_id] ~ dcauchy(10,sigma_site),
    sigma_site ~ dcauchy(1,1),
    c(bt,bno,bp,bd,bj) ~ dnorm(0,1),
    scale ~ dcauchy(0,2)
  ),
  data=zb,
  constraints=list(scale="lower=0"),
  start=list(scale=2)
)

```

